<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Northwest Corner Method</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        background-color: #f2eafa;
        color: #5c4b7d;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
      }

      .screen {
        display: none;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        background: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }

      .active {
        display: flex;
      }

      input[type="number"] {
        width: 60px;
        padding: 5px;
        margin: 2px;
        border: 1px solid #ccc;
        border-radius: 5px;
      }

      button {
        background-color: #b583d8;
        color: white;
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
      }

      button:hover {
        background-color: #9c6cc1;
      }

      .button-container {
        display: flex;
        gap: 10px;
        justify-content: center;
      }

      table {
        border-collapse: collapse;
      }

      td,
      th {
        border: 1px solid #b583d8;
        padding: 10px;
        text-align: center;
        min-width: 60px;
      }

      th {
        background-color: #f0dffb;
      }

      .step {
        margin-top: 20px;
      }

      .diagonal-cell {
        position: relative;
        width: 80px;
        height: 60px;
      }

      .diagonal-cell::after {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          to left bottom,
          transparent 49.5%,
          #b583d8 49.5%,
          #b583d8 50.5%,
          transparent 50.5%
        );
        z-index: 1;
        pointer-events: none;
      }

      .top-value {
        position: absolute;
        top: 10px;
        right: 20px;
        font-weight: bold;
        font-size: 17px;
      }

      .bottom-value {
        position: absolute;
        bottom: 10px;
        left: 20px;
        font-weight: bold;
        font-size: 17px;
      }

      .equal {
        color: green;
      }

      .not-equal {
        color: red;
      }

      #stepHistoryContainer {
        display: none;
      }

      .history-btn {
        background-color: #b583d8;
        color: white;
        padding: 8px 12px;
        border: none;
        border-radius: 4px;
        margin-left: 10px;
        cursor: pointer;
      }

      .history-btn:hover {
        background-color: #9c6cc1;
      }
    </style>
  </head>

  <body>
    <div class="screen active" id="startScreen">
      <h2>NORTHWEST CORNER METHOD</h2>
      <button onclick="nextScreen('dimensionScreen')">START</button>
    </div>

    <div class="screen" id="dimensionScreen">
      <h2>NORTHWEST CORNER METHOD</h2>
      <label
        >Supply Points: <input type="number" id="supplyCount" min="1"
      /></label>
      <label
        >Demand Points: <input type="number" id="demandCount" min="1"
      /></label>
      <div class="button-container">
        <button onclick="previousScreen()">Back</button>
        <button onclick="generateCombinedMatrix()">Generate Input Table</button>
      </div>
    </div>

    <div class="screen" id="inputMatrixScreen">
      <h2>Enter Cost, Supply and Demand</h2>
      <table id="inputMatrix"></table>
      <div class="button-container">
        <button onclick="goBackToDimensionScreen()">Back</button>
        <button onclick="solveWithNorthwestCorner()">Solve</button>
      </div>
    </div>

    <div class="screen" id="resultScreen">
      <h2>Step-by-Step Allocation</h2>
      <div id="stepOutput"></div>
      <table id="allocationTable"></table>
      <div class="button-container">
        <button onclick="goBackToInputMatrix()">Back</button>
        <button id="nextStepButton" onclick="showNextStep()">Next Step</button>
      </div>
      <button id="toggleStepHistoryBtn" style="margin-top: 10px">
        Show Step History
      </button>
      <button id="updateHistoryBtn" class="history-btn">Update History</button>
      <div
        id="stepHistoryContainer"
        style="
          display: none;
          max-height: 350px;
          overflow-y: auto;
          width: 100%;
          margin-top: 10px;
          border: 1px solid #b583d8;
          border-radius: 8px;
          background: #faf7ff;
          padding: 10px;
        "
      ></div>
    </div>

    <div class="screen" id="steppingStoneScreen">
      <h2>Stepping Stone Method</h2>
      <div id="steppingStoneOutput"></div>
      <table id="steppingStoneTable"></table>
      <div class="button-container">
        <button onclick="goBackToInputMatrix()">Back</button>
        <button id="restartButton" onclick="location.reload()">Restart</button>
      </div>
    </div>

    <script>
      let supplyCount, demandCount;
      let supply = [],
        demand = [],
        costMatrix = [],
        steps = [],
        allocationMatrix = [];
      let stepIndex = 0;
      let screenHistory = ["startScreen"]; // Initialize with the first screen
      let steppingStoneSteps = [];
      let steppingStoneIndex = 0;
      let dummyAdded = false; // Flag to track if dummy row/column has been added
      let totalSupply = 0,
        totalDemand = 0;
      // Store input values to preserve them when navigating back
      let savedInputValues = {};

      function nextScreen(screenId) {
        screenHistory.push(screenId); // Add the current screen to history
        document
          .querySelectorAll(".screen")
          .forEach((s) => s.classList.remove("active"));
        document.getElementById(screenId).classList.add("active");
      }

      function previousScreen() {
        if (screenHistory.length > 1) {
          screenHistory.pop(); // Remove the current screen
          const previousScreenId = screenHistory[screenHistory.length - 1]; // Get the previous screen
          document
            .querySelectorAll(".screen")
            .forEach((s) => s.classList.remove("active"));
          document.getElementById(previousScreenId).classList.add("active");
        }
      }

      // Function to go back to dimension screen
      function goBackToDimensionScreen() {
        screenHistory = ["dimensionScreen"];
        document
          .querySelectorAll(".screen")
          .forEach((s) => s.classList.remove("active"));
        document.getElementById("dimensionScreen").classList.add("active");
      }

      // Special function to go back to input matrix from result or stepping stone screens
      function goBackToInputMatrix() {
        // First, save the current dimensions if they're not already saved
        if (!savedInputValues.supplyCount || !savedInputValues.demandCount) {
          savedInputValues.supplyCount = supplyCount;
          savedInputValues.demandCount = demandCount;
        }

        // Reset the screen history to show only the input matrix screen
        screenHistory = ["inputMatrixScreen"];
        document
          .querySelectorAll(".screen")
          .forEach((s) => s.classList.remove("active"));
        document.getElementById("inputMatrixScreen").classList.add("active");

        // Regenerate the input matrix with saved dimensions
        regenerateInputMatrix();

        // Reset the state
        resetState();
      }

      function regenerateInputMatrix() {
        // Get the saved dimensions
        const savedSupplyCount = parseInt(savedInputValues.supplyCount);
        const savedDemandCount = parseInt(savedInputValues.demandCount);

        if (
          !savedSupplyCount ||
          !savedDemandCount ||
          savedSupplyCount < 1 ||
          savedDemandCount < 1
        ) {
          // If no saved dimensions, go back to dimension screen
          nextScreen("dimensionScreen");
          return;
        }

        // Update the current dimensions
        supplyCount = savedSupplyCount;
        demandCount = savedDemandCount;

        // Update the dimension inputs
        document.getElementById("supplyCount").value = supplyCount;
        document.getElementById("demandCount").value = demandCount;

        const table = document.getElementById("inputMatrix");
        table.innerHTML = ""; // Clear any existing table content

        // Create table header
        const header = document.createElement("tr");
        header.innerHTML =
          "<th></th>" +
          Array.from(
            { length: demandCount },
            (_, j) => `<th>D${j + 1}</th>`
          ).join("") +
          "<th>SUPPLY</th>";
        table.appendChild(header);

        // Create rows for supply and cost inputs
        for (let i = 0; i < supplyCount; i++) {
          const row = document.createElement("tr");
          row.innerHTML =
            `<th>S${i + 1}</th>` +
            Array.from(
              { length: demandCount },
              (_, j) =>
                `<td><input type="number" id="cost${i}_${j}" min="0" /></td>`
            ).join("") +
            `<td><input type="number" id="supply${i}" min="0" /></td>`;
          table.appendChild(row);
        }

        // Create row for demand inputs
        const demandRow = document.createElement("tr");
        demandRow.innerHTML =
          "<th>DEMAND</th>" +
          Array.from(
            { length: demandCount },
            (_, j) => `<td><input type="number" id="demand${j}" min="0" /></td>`
          ).join("") +
          '<td class="diagonal-cell"><div class="top-value" id="totalSupply"></div><div class="bottom-value" id="totalDemand"></div></td>';
        table.appendChild(demandRow);

        // Restore any previously saved values
        restoreInputValues();

        // Update totals
        updateTotals();
      }

      function updateTotals() {
        let supplyTotal = 0;
        let demandTotal = 0;

        // Calculate total supply
        for (let i = 0; i < supplyCount; i++) {
          const supplyInput = document.getElementById(`supply${i}`);
          if (supplyInput && !isNaN(parseInt(supplyInput.value))) {
            supplyTotal += parseInt(supplyInput.value);
          }
        }

        // Calculate total demand
        for (let j = 0; j < demandCount; j++) {
          const demandInput = document.getElementById(`demand${j}`);
          if (demandInput && !isNaN(parseInt(demandInput.value))) {
            demandTotal += parseInt(demandInput.value);
          }
        }

        // Update the total display
        const totalSupplyElement = document.getElementById("totalSupply");
        const totalDemandElement = document.getElementById("totalDemand");

        if (totalSupplyElement && totalDemandElement) {
          totalSupplyElement.textContent = supplyTotal;
          totalDemandElement.textContent = demandTotal;

          // Set color based on equality
          if (supplyTotal === demandTotal) {
            totalSupplyElement.className = "top-value equal";
            totalDemandElement.className = "bottom-value equal";
          } else {
            totalSupplyElement.className = "top-value not-equal";
            totalDemandElement.className = "bottom-value not-equal";
          }
        }

        // Save the totals
        totalSupply = supplyTotal;
        totalDemand = demandTotal;
      }

      function resetState() {
        // Reset the nextStepButton to its initial state
        const nextStepButton = document.getElementById("nextStepButton");
        if (nextStepButton) {
          nextStepButton.textContent = "Next Step";
          nextStepButton.onclick = showNextStep;
        }

        // Clear steps and reset stepIndex
        steps = [];
        stepIndex = 0;
        dummyAdded = false;

        // Clear the allocation table and step output
        const allocationTable = document.getElementById("allocationTable");
        if (allocationTable) {
          allocationTable.innerHTML = "";
        }

        const stepOutput = document.getElementById("stepOutput");
        if (stepOutput) {
          stepOutput.innerHTML = "";
        }

        // Remove the cost computation table if it exists
        const existingCostComputationDiv =
          document.getElementById("costComputationDiv");
        if (existingCostComputationDiv) {
          existingCostComputationDiv.remove();
        }
      }

      function saveInputValues() {
        // Save supply and demand counts
        savedInputValues.supplyCount =
          document.getElementById("supplyCount").value;
        savedInputValues.demandCount =
          document.getElementById("demandCount").value;

        // Save cost matrix values
        for (let i = 0; i < supplyCount; i++) {
          for (let j = 0; j < demandCount; j++) {
            const costInput = document.getElementById(`cost${i}_${j}`);
            if (costInput) {
              savedInputValues[`cost${i}_${j}`] = costInput.value;
            }
          }
        }

        // Save supply values
        for (let i = 0; i < supplyCount; i++) {
          const supplyInput = document.getElementById(`supply${i}`);
          if (supplyInput) {
            savedInputValues[`supply${i}`] = supplyInput.value;
          }
        }

        // Save demand values
        for (let j = 0; j < demandCount; j++) {
          const demandInput = document.getElementById(`demand${j}`);
          if (demandInput) {
            savedInputValues[`demand${j}`] = demandInput.value;
          }
        }
      }

      function restoreInputValues() {
        // Restore cost matrix values
        for (let i = 0; i < supplyCount; i++) {
          for (let j = 0; j < demandCount; j++) {
            const costInput = document.getElementById(`cost${i}_${j}`);
            if (costInput && savedInputValues[`cost${i}_${j}`]) {
              costInput.value = savedInputValues[`cost${i}_${j}`];
            }
          }
        }

        // Restore supply values
        for (let i = 0; i < supplyCount; i++) {
          const supplyInput = document.getElementById(`supply${i}`);
          if (supplyInput && savedInputValues[`supply${i}`]) {
            supplyInput.value = savedInputValues[`supply${i}`];
          }
        }

        // Restore demand values
        for (let j = 0; j < demandCount; j++) {
          const demandInput = document.getElementById(`demand${j}`);
          if (demandInput && savedInputValues[`demand${j}`]) {
            demandInput.value = savedInputValues[`demand${j}`];
          }
        }
      }

      function generateCombinedMatrix() {
        supplyCount = parseInt(document.getElementById("supplyCount").value);
        demandCount = parseInt(document.getElementById("demandCount").value);

        if (
          !supplyCount ||
          !demandCount ||
          supplyCount < 1 ||
          demandCount < 1
        ) {
          alert("Please enter valid dimensions.");
          return;
        }

        // Save the dimensions
        savedInputValues.supplyCount = supplyCount;
        savedInputValues.demandCount = demandCount;

        const table = document.getElementById("inputMatrix");
        table.innerHTML = ""; // Clear any existing table content

        // Create table header
        const header = document.createElement("tr");
        header.innerHTML =
          "<th></th>" +
          Array.from(
            { length: demandCount },
            (_, j) => `<th>D${j + 1}</th>`
          ).join("") +
          "<th>SUPPLY</th>";
        table.appendChild(header);

        // Create rows for supply and cost inputs
        for (let i = 0; i < supplyCount; i++) {
          const row = document.createElement("tr");
          row.innerHTML =
            `<th>S${i + 1}</th>` +
            Array.from(
              { length: demandCount },
              (_, j) =>
                `<td><input type="number" id="cost${i}_${j}" min="0" /></td>`
            ).join("") +
            `<td><input type="number" id="supply${i}" min="0" onchange="updateTotals()" /></td>`;
          table.appendChild(row);
        }

        // Create row for demand inputs
        const demandRow = document.createElement("tr");
        demandRow.innerHTML =
          "<th>DEMAND</th>" +
          Array.from(
            { length: demandCount },
            (_, j) =>
              `<td><input type="number" id="demand${j}" min="0" onchange="updateTotals()" /></td>`
          ).join("") +
          '<td class="diagonal-cell"><div class="top-value" id="totalSupply">0</div><div class="bottom-value" id="totalDemand">0</div></td>';
        table.appendChild(demandRow);

        // Restore any previously saved values
        restoreInputValues();

        // Update totals
        updateTotals();

        // Switch to the input matrix screen
        nextScreen("inputMatrixScreen");
      }

      function solveWithNorthwestCorner() {
        // Save input values before processing
        saveInputValues();

        // Check if all inputs exist before trying to read them
        const allInputsExist = checkAllInputsExist();
        if (!allInputsExist) {
          alert(
            "Some input fields are missing. Please regenerate the input table."
          );
          return;
        }

        supply = [];
        demand = [];

        // Read supply values
        for (let i = 0; i < supplyCount; i++) {
          const supplyInput = document.getElementById(`supply${i}`);
          if (supplyInput) {
            supply.push(parseInt(supplyInput.value));
          } else {
            alert(`Supply input for S${i + 1} is missing.`);
            return;
          }
        }

        // Read demand values
        for (let j = 0; j < demandCount; j++) {
          const demandInput = document.getElementById(`demand${j}`);
          if (demandInput) {
            demand.push(parseInt(demandInput.value));
          } else {
            alert(`Demand input for D${j + 1} is missing.`);
            return;
          }
        }

        if (supply.includes(NaN) || demand.includes(NaN)) {
          alert("Please fill in all supply and demand values.");
          return;
        }

        costMatrix = [];
        // Read cost matrix values
        for (let i = 0; i < supplyCount; i++) {
          const row = [];
          for (let j = 0; j < demandCount; j++) {
            const costInput = document.getElementById(`cost${i}_${j}`);
            if (costInput) {
              row.push(parseInt(costInput.value));
            } else {
              alert(`Cost input for S${i + 1}-D${j + 1} is missing.`);
              return;
            }
          }
          costMatrix.push(row);
        }

        if (costMatrix.flat().includes(NaN)) {
          alert("Please fill in all cost values.");
          return;
        }

        // Calculate totals
        totalSupply = supply.reduce((a, b) => a + b, 0);
        totalDemand = demand.reduce((a, b) => a + b, 0);

        // Initialize allocation matrix without adding dummy row/column yet
        allocationMatrix = Array.from({ length: supplyCount }, () =>
          Array(demandCount).fill("")
        );
        steps = [];
        stepIndex = 0;
        dummyAdded = false;

        // First step: Show the initial state
        steps.push({
          message: "Initial state. Click 'Next Step' to begin allocation.",
          snapshot: allocationMatrix.map((row) => [...row]),
          supplyLeft: [...supply],
          demandLeft: [...demand],
          needsDummy: totalSupply !== totalDemand,
        });

        nextScreen("resultScreen");
        showNextStep();
      }

      function checkAllInputsExist() {
        // Check if all required inputs exist
        for (let i = 0; i < supplyCount; i++) {
          if (!document.getElementById(`supply${i}`)) {
            return false;
          }
          for (let j = 0; j < demandCount; j++) {
            if (!document.getElementById(`cost${i}_${j}`)) {
              return false;
            }
          }
        }

        for (let j = 0; j < demandCount; j++) {
          if (!document.getElementById(`demand${j}`)) {
            return false;
          }
        }

        return true;
      }

      function showNextStep() {
        const stepOutput = document.getElementById("stepOutput");
        const allocationTable = document.getElementById("allocationTable");
        const nextStepButton = document.getElementById("nextStepButton");

        if (stepIndex === 0) {
          // First step: Show initial state and add dummy if needed
          const { message, snapshot, supplyLeft, demandLeft, needsDummy } =
            steps[0];

          // Clear the allocation table
          allocationTable.innerHTML = "";

          // Create the table header
          const header = document.createElement("tr");
          header.innerHTML =
            "<th></th>" +
            demand.map((_, j) => `<th>D${j + 1}</th>`).join("") +
            "<th>SUPPLY</th>";
          allocationTable.appendChild(header);

          // Populate the table rows with the current snapshot
          snapshot.forEach((row, i) => {
            const tr = document.createElement("tr");
            tr.innerHTML =
              `<th>S${i + 1}</th>` +
              row
                .map((val, j) => {
                  const cost = costMatrix[i][j];
                  return `<td><span style="color: gray;">${cost}</span></td>`;
                })
                .join("") +
              `<td>${supplyLeft[i]}</td>`;
            allocationTable.appendChild(tr);
          });

          // Add the demand row
          const demandRow = document.createElement("tr");
          demandRow.innerHTML =
            "<th>DEMAND</th>" +
            demandLeft.map((val) => `<td>${val}</td>`).join("") +
            `<td class="diagonal-cell">
            <div class="top-value ${
              needsDummy ? "not-equal" : "equal"
            }">${totalSupply}</div>
            <div class="bottom-value ${
              needsDummy ? "not-equal" : "equal"
            }">${totalDemand}</div>
          </td>`;
          allocationTable.appendChild(demandRow);

          // Update the step output
          if (needsDummy) {
            stepOutput.innerHTML = `<p class="step">Total supply (${totalSupply}) and demand (${totalDemand}) are not equal. Click 'Next Step' to add a dummy row/column.</p>`;
          } else {
            stepOutput.innerHTML = `<p class="step">${message}</p>`;
          }

          stepIndex++;
        } else if (
          stepIndex === 1 &&
          totalSupply !== totalDemand &&
          !dummyAdded
        ) {
          // Add dummy row/column if needed
          if (totalSupply > totalDemand) {
            // Add dummy demand column
            demand.push(totalSupply - totalDemand);
            for (let i = 0; i < costMatrix.length; i++) {
              costMatrix[i].push(0); // Cost to dummy demand
            }
            demandCount++;

            // Update allocation matrix
            allocationMatrix = Array.from({ length: supplyCount }, () =>
              Array(demandCount).fill("")
            );

            // Push a step for adding dummy demand column
            steps.push({
              message: `Added dummy demand column DD${demandCount} with demand ${
                totalSupply - totalDemand
              }.`,
              snapshot: allocationMatrix.map((row) => [...row]),
              supplyLeft: [...supply],
              demandLeft: [...demand],
            });

            stepOutput.innerHTML = `<p class="step">Added dummy demand column DD${demandCount} with demand ${
              totalSupply - totalDemand
            }.</p>`;
          } else if (totalDemand > totalSupply) {
            // Add dummy supply row
            supply.push(totalDemand - totalSupply);
            const dummyRow = Array(demandCount).fill(0); // Cost from dummy supply
            costMatrix.push(dummyRow);
            supplyCount++;

            // Update allocation matrix
            allocationMatrix = Array.from({ length: supplyCount }, () =>
              Array(demandCount).fill("")
            );

            // Push a step for adding dummy supply row
            steps.push({
              message: `Added dummy supply row DS${supplyCount} with supply ${
                totalDemand - totalSupply
              }.`,
              snapshot: allocationMatrix.map((row) => [...row]),
              supplyLeft: [...supply],
              demandLeft: [...demand],
            });

            stepOutput.innerHTML = `<p class="step">Added dummy supply row DS${supplyCount} with supply ${
              totalDemand - totalSupply
            }.</p>`;
          }

          dummyAdded = true;

          // Show the updated table with dummy row/column
          allocationTable.innerHTML = "";

          // Create the table header
          const header = document.createElement("tr");
          header.innerHTML =
            "<th></th>" +
            demand
              .map((_, j) => {
                if (j === demandCount - 1 && totalSupply > totalDemand) {
                  return `<th>DD${j + 1}</th>`;
                }
                return `<th>D${j + 1}</th>`;
              })
              .join("") +
            "<th>SUPPLY</th>";
          allocationTable.appendChild(header);

          // Populate the table rows with the current snapshot
          for (let i = 0; i < supplyCount; i++) {
            const tr = document.createElement("tr");
            let rowHeader = `<th>${
              i === supplyCount - 1 && totalDemand > totalSupply
                ? "DS"
                : "S" + (i + 1)
            }</th>`;

            let rowContent = "";
            for (let j = 0; j < demandCount; j++) {
              const cost = costMatrix[i][j];
              rowContent += `<td><span style="color: gray;">${cost}</span></td>`;
            }

            tr.innerHTML = rowHeader + rowContent + `<td>${supply[i]}</td>`;
            allocationTable.appendChild(tr);
          }

          // Add the demand row
          const demandRow = document.createElement("tr");
          demandRow.innerHTML =
            "<th>DEMAND</th>" +
            demand.map((val) => `<td>${val}</td>`).join("") +
            `<td class="diagonal-cell">
            <div class="top-value equal">${supply.reduce(
              (a, b) => a + b,
              0
            )}</div>
            <div class="bottom-value equal">${demand.reduce(
              (a, b) => a + b,
              0
            )}</div>
          </td>`;
          allocationTable.appendChild(demandRow);

          // Prepare for allocation steps
          let supplyLeft = [...supply],
            demandLeft = [...demand];
          let i = 0,
            j = 0;

          while (i < supplyCount && j < demandCount) {
            let alloc = Math.min(supplyLeft[i], demandLeft[j]);
            allocationMatrix[i][j] = alloc;

            steps.push({
              message: `Allocating ${alloc} units from ${
                i === supplyCount - 1 && totalDemand > totalSupply ? "DS" : "S"
              }${i + 1} to ${
                j === demandCount - 1 && totalSupply > totalDemand ? "DD" : "D"
              }${j + 1}`,
              snapshot: allocationMatrix.map((row) => [...row]),
              supplyLeft: [...supplyLeft],
              demandLeft: [...demandLeft],
            });

            supplyLeft[i] -= alloc;
            demandLeft[j] -= alloc;

            if (supplyLeft[i] === 0) i++;
            if (demandLeft[j] === 0) j++;
          }

          stepIndex++;
        } else if (
          (stepIndex > 1 || (stepIndex === 1 && totalSupply === totalDemand)) &&
          stepIndex <= steps.length
        ) {
          // Regular allocation steps
          let currentStep;

          if (totalSupply === totalDemand && stepIndex === 1) {
            // If supply equals demand, we need to prepare the allocation steps
            let supplyLeft = [...supply],
              demandLeft = [...demand];
            let i = 0,
              j = 0;

            while (i < supplyCount && j < demandCount) {
              let alloc = Math.min(supplyLeft[i], demandLeft[j]);
              allocationMatrix[i][j] = alloc;

              steps.push({
                message: `Allocating ${alloc} units from S${i + 1} to D${
                  j + 1
                }`,
                snapshot: allocationMatrix.map((row) => [...row]),
                supplyLeft: [...supplyLeft],
                demandLeft: [...demandLeft],
              });

              supplyLeft[i] -= alloc;
              demandLeft[j] -= alloc;

              if (supplyLeft[i] === 0) i++;
              if (demandLeft[j] === 0) j++;
            }

            currentStep = steps[1]; // Get the first allocation step
          } else {
            // Get the current step (adjusted for dummy step)
            const stepAdjustment = totalSupply !== totalDemand ? 1 : 0;
            currentStep = steps[stepIndex - stepAdjustment];
          }

          const { message, snapshot, supplyLeft, demandLeft } = currentStep;

          // Clear the allocation table
          allocationTable.innerHTML = "";

          // Create the table header
          const header = document.createElement("tr");
          header.innerHTML =
            "<th></th>" +
            demand
              .map((_, j) => {
                if (j === demandCount - 1 && totalSupply > totalDemand) {
                  return `<th>DD${j + 1}</th>`;
                }
                return `<th>D${j + 1}</th>`;
              })
              .join("") +
            "<th>SUPPLY</th>";
          allocationTable.appendChild(header);

          // Populate the table rows with the current snapshot
          snapshot.forEach((row, i) => {
            const tr = document.createElement("tr");
            let rowHeader = `<th>${
              i === supplyCount - 1 && totalDemand > totalSupply
                ? "DS" + (i + 1)
                : "S" + (i + 1)
            }</th>`;

            let rowContent = "";
            for (let j = 0; j < demandCount; j++) {
              const cost = costMatrix[i][j];
              const val = row[j];
              if (val === "" || val === 0 || val === undefined) {
                if (supplyLeft[i] === 0 || demandLeft[j] === 0) {
                  rowContent += `<td style="color: red;">X</td>`;
                } else {
                  rowContent += `<td><span style="color: gray;">${cost}</span></td>`;
                }
              } else {
                rowContent += `<td><span style="color: black; font-weight: bold;">${val} | <span style="color: gray;">${cost}</span></span></td>`;
              }
            }

            tr.innerHTML = rowHeader + rowContent + `<td>${supplyLeft[i]}</td>`;
            allocationTable.appendChild(tr);
          });

          // Add the demand row
          const demandRow = document.createElement("tr");
          demandRow.innerHTML =
            "<th>DEMAND</th>" +
            demandLeft.map((val) => `<td>${val}</td>`).join("") +
            `<td class="diagonal-cell">
            <div class="top-value equal">${supply.reduce(
              (a, b) => a + b,
              0
            )}</div>
            <div class="bottom-value equal">${demand.reduce(
              (a, b) => a + b,
              0
            )}</div>
          </td>`;
          allocationTable.appendChild(demandRow);

          // Update the step output
          stepOutput.innerHTML = `<p class="step">${message}</p>`;
          stepIndex++;
        } else {
          // Final step: Set supply and demand to zero
          allocationTable.innerHTML = "";
          const header = document.createElement("tr");
          header.innerHTML =
            "<th></th>" +
            demand
              .map((_, j) => {
                if (j === demandCount - 1 && totalSupply > totalDemand) {
                  return `<th>DD${j + 1}</th>`;
                }
                return `<th>D${j + 1}</th>`;
              })
              .join("") +
            "<th>SUPPLY</th>";
          allocationTable.appendChild(header);

          allocationMatrix.forEach((row, i) => {
            const tr = document.createElement("tr");
            let rowHeader = `<th>${
              i === supplyCount - 1 && totalDemand > totalSupply
                ? "DS" + (i + 1)
                : "S" + (i + 1)
            }</th>`;

            let rowContent = "";
            for (let j = 0; j < demandCount; j++) {
              const val = row[j];
              rowContent += `<td>${val}</td>`;
            }

            tr.innerHTML = rowHeader + rowContent + `<td>0</td>`; // Set supply to zero
            allocationTable.appendChild(tr);
          });

          const demandRow = document.createElement("tr");
          demandRow.innerHTML =
            "<th>DEMAND</th>" +
            demand.map(() => `<td>0</td>`).join("") +
            `<td class="diagonal-cell">
            <div class="top-value equal">0</div>
            <div class="bottom-value equal">0</div>
          </td>`;
          allocationTable.appendChild(demandRow);

          // Update the step output
          stepOutput.innerHTML = `<p class="step" style="color: green;">All allocations completed. Supply and demand are now zero.</p>`;

          // Overwrite the button to "Compute Cost"
          nextStepButton.textContent = "Compute Cost";
          nextStepButton.onclick = displayFinalCost;
        }
      }

      function displayFinalCost() {
        const stepOutput = document.getElementById("stepOutput");
        const allocationTable = document.getElementById("allocationTable");
        const nextStepButton = document.getElementById("nextStepButton");
        let totalCost = 0;

        // Check if the cost computation table already exists
        const existingCostComputationDiv =
          document.getElementById("costComputationDiv");
        if (existingCostComputationDiv) {
          existingCostComputationDiv.remove(); // Remove the existing table to avoid duplicates
        }

        // Create the cost computation table
        let html =
          '<h3>Cost Computation</h3><table border="1"><tr><th>From</th><th>To</th><th>Allocation</th><th>Unit Cost</th><th>Total</th></tr>';
        const costDetails = { totalCost: 0, allocations: [] };

        for (let i = 0; i < supplyCount; i++) {
          for (let j = 0; j < demandCount; j++) {
            const alloc = allocationMatrix[i][j];
            if (alloc !== "") {
              const cost = costMatrix[i][j];
              const total = alloc * cost;
              totalCost += total;

              const fromLabel =
                i === supplyCount - 1 && totalDemand > totalSupply
                  ? `DS${i + 1}`
                  : `S${i + 1}`;
              const toLabel =
                j === demandCount - 1 && totalSupply > totalDemand
                  ? `DD${j + 1}`
                  : `D${j + 1}`;

              html += `<tr><td>${fromLabel}</td><td>${toLabel}</td><td>${alloc}</td><td>${cost}</td><td>${total}</td></tr>`;

              // Add to cost details for step history
              costDetails.allocations.push({
                row: i,
                col: j,
                amount: alloc,
                cost: cost,
              });
            }
          }
        }
        costDetails.totalCost = totalCost;

        // Add cost details to the final step
        if (steps.length > 0) {
          steps[steps.length - 1].costDetails = costDetails;
        }

        html += `<tr><td colspan="4"><strong>Total Cost</strong></td><td><strong>${totalCost}</strong></td></tr></table>`;

        // Append the cost computation table below the allocation table
        const costComputationDiv = document.createElement("div");
        costComputationDiv.id = "costComputationDiv"; // Add an ID to identify the div
        costComputationDiv.innerHTML = html;
        allocationTable.parentNode.insertBefore(
          costComputationDiv,
          allocationTable.nextSibling
        );

        // Update the button to "Solve Stepping Stone Method"
        nextStepButton.textContent = "Solve Stepping Stone Method";
        nextStepButton.onclick = () => nextScreen("steppingStoneScreen");
      }

      function solveSteppingStone() {
        steppingStoneSteps = []; // Reset stepping stone steps
        steppingStoneIndex = 0;

        let isOptimal = false;

        while (!isOptimal) {
          const opportunityCosts = calculateOpportunityCosts();
          const mostNegativeCost = Math.min(
            ...opportunityCosts.map((cell) => cell.cost)
          );

          if (mostNegativeCost >= 0) {
            isOptimal = true;
            steppingStoneSteps.push({
              message: "The solution is optimal.",
              details: "No negative opportunity costs remain.",
            });
          } else {
            const cellToImprove = opportunityCosts.find(
              (cell) => cell.cost === mostNegativeCost
            );
            adjustAllocations(cellToImprove);
            steppingStoneSteps.push({
              message: `Improving allocation for cell S${
                cellToImprove.row + 1
              }-D${cellToImprove.col + 1}.`,
              details: `Opportunity cost: ${mostNegativeCost}`,
            });
          }
        }

        // Switch to the stepping stone screen
        nextScreen("steppingStoneScreen");
        showSteppingStoneStep();
      }

      function calculateOpportunityCosts() {
        const opportunityCosts = [];

        for (let i = 0; i < supplyCount; i++) {
          for (let j = 0; j < demandCount; j++) {
            if (allocationMatrix[i][j] === "") {
              const cost = calculateCostForCell(i, j);
              opportunityCosts.push({ row: i, col: j, cost });
            }
          }
        }

        return opportunityCosts;
      }

      function calculateCostForCell(row, col) {
        // Implement logic to calculate the opportunity cost for a specific cell
        // This involves forming a closed loop and summing the costs along the loop
        // Alternate between adding and subtracting costs along the loop
        return 0; // Placeholder
      }

      function adjustAllocations(cell) {
        // Implement logic to adjust allocations along the closed loop
        // Increase allocation in the unallocated cell and adjust other allocations
      }

      function showSteppingStoneStep() {
        const stepOutput = document.getElementById("steppingStoneOutput");
        const steppingStoneTable =
          document.getElementById("steppingStoneTable");

        if (steppingStoneIndex < steppingStoneSteps.length) {
          const { message, details } = steppingStoneSteps[steppingStoneIndex];
          stepOutput.innerHTML = `
          <div class="step">
            <p><strong>${message}</strong></p>
            <p>${details}</p>
          </div>
        `;
          steppingStoneIndex++;
        } else {
          stepOutput.innerHTML = `
          <div class="step" style="color: green;">
            <p><strong>Stepping Stone Method Completed.</strong></p>
            <p>The solution is optimal.</p>
          </div>
        `;
        }
      }

      // --- Step History Feature ---
      document.addEventListener("DOMContentLoaded", function () {
        const btn = document.getElementById("toggleStepHistoryBtn");
        if (btn) {
          btn.onclick = function () {
            const container = document.getElementById("stepHistoryContainer");
            if (!container) return;

            // Toggle visibility
            if (
              container.style.display === "none" ||
              !container.style.display
            ) {
              // Show and render
              container.style.display = "block";
              btn.textContent = "Hide Step History";
              renderStepHistory();
            } else {
              // Hide
              container.style.display = "none";
              btn.textContent = "Show Step History";
            }
          };
        }
        const prevBtn = document.getElementById("previousStepBtn");
        if (prevBtn) prevBtn.addEventListener("click", showPreviousStep);
        if (nextBtn) nextBtn.addEventListener("click", showNextStep);
        updateButtonStates();
      });

      const updateBtn = document.getElementById("updateHistoryBtn");
      if (updateBtn) {
        updateBtn.onclick = function () {
          renderStepHistory();
        };
      }

      function renderStepHistory() {
        const container = document.getElementById("stepHistoryContainer");
        if (!container) return;
        container.innerHTML = "";
        const scrollTop = container.scrollTop;

        // Only show steps up to the current stepIndex (not all steps)
        for (let k = 0; k < stepIndex && k < steps.length; k++) {
          const step = steps[k];
          if (!step) continue;

          const stepDiv = document.createElement("div");
          stepDiv.className = "history-step";
          stepDiv.style.marginBottom = "18px";
          stepDiv.innerHTML = `<div style='font-weight:bold;margin-bottom:4px;'>Step ${
            k + 1
          }:</div><div>${step.message}</div>`;

          // Add cost calculation details if it's the final step
          if (k === steps.length - 1 && step.costDetails) {
            const costDiv = document.createElement("div");
            costDiv.style.marginTop = "8px";
            costDiv.style.padding = "8px";
            costDiv.style.backgroundColor = "#f0dffb";
            costDiv.style.borderRadius = "4px";

            const costDetails = step.costDetails;
            let costText =
              '<div style="font-weight:bold; margin-bottom:4px;">Cost Calculation Details:</div>';
            costText +=
              '<div>Final Cost: <span style="color:green; font-weight:bold;">$' +
              costDetails.totalCost +
              "</span></div>";
            costText += '<div style="margin-top:4px;">Breakdown:</div>';

            costDetails.allocations.forEach((alloc) => {
              costText += `<div style="margin-top:4px;">
          S${alloc.row + 1} → D${alloc.col + 1}: <span style="color:gray;">${
                alloc.amount
              }</span> × <span style="color:gray;">${
                alloc.cost
              }</span> = <span style="color:green;">$${
                alloc.amount * alloc.cost
              }</span>
        </div>`;
            });

            costDiv.innerHTML = costText;
            stepDiv.appendChild(costDiv);
          }

          // Render table snapshot only if snapshot exists
          if (step.snapshot) {
            const table = document.createElement("table");
            table.style.margin = "8px 0";
            table.style.borderCollapse = "collapse";

            // Header
            const header = document.createElement("tr");
            header.innerHTML =
              "<th></th>" +
              demand.map((_, j) => `<th>D${j + 1}</th>`).join("") +
              "<th>SUPPLY</th>";
            table.appendChild(header);

            // Rows
            step.snapshot.forEach((row, i) => {
              const tr = document.createElement("tr");
              tr.innerHTML =
                `<th>S${i + 1}</th>` +
                row
                  .map((val, j) => {
                    const cost =
                      costMatrix[i] && costMatrix[i][j] !== undefined
                        ? costMatrix[i][j]
                        : "";
                    if (val === "" || val === 0 || val === undefined) {
                      return `<td><span style='color:gray;'>${cost}</span></td>`;
                    } else {
                      return `<td><span style='color:black;font-weight:bold;'>${val} | <span style='color:gray;'>${cost}</span></span></td>`;
                    }
                  })
                  .join("") +
                `<td>${step.supplyLeft ? step.supplyLeft[i] : ""}</td>`;
              table.appendChild(tr);
            });

            // Demand row
            if (step.demandLeft) {
              const demandRow = document.createElement("tr");
              demandRow.innerHTML =
                "<th>DEMAND</th>" +
                step.demandLeft.map((val) => `<td>${val}</td>`).join("") +
                "<td></td>";
              table.appendChild(demandRow);
            }

            stepDiv.appendChild(table);
          }

          container.appendChild(stepDiv);
          container.scrollTop = scrollTop;
        }

        container.scrollTop = scrollTop;
      }
    </script>
  </body>
</html>
